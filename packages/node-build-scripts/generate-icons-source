#!/usr/bin/env node
/**
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 * @fileoverview Generates icons Sass and TypeScript source code from JSON metadata about icons.
 */

// @ts-check
const fs = require("fs");
const path = require("path");
const SVGO = require("svgo");
const { COPYRIGHT_HEADER } = require("./constants");

const svgo = new SVGO({ plugins: [{ convertShapeToPath: { convertArcs: true } }] });

/**
 * @typedef {Object} IconMetadata
 * @property {string} name - icon name for display
 * @property {string} className - CSS class name
 * @property {string} tags - comma separated list of tags describing this icon
 * @property {string} group - group to which this icon belongs
 * @property {string} content - unicode character for icon glyph in font
 */

/** @type {IconMetadata[]} */
const ICONS_METADATA = require(path.resolve(process.cwd(), "./resources/icons/icons.json")).sort((a, b) =>
    a.className.localeCompare(b.className),
);
const GENERATED_SRC_DIR = path.resolve(process.cwd(), "./src/generated");

if (!fs.existsSync(GENERATED_SRC_DIR)) {
    fs.mkdirSync(GENERATED_SRC_DIR);
}

// great big map for iteration
writeLinesToFile(
    "_icon-map.scss",
    '@import "icon-variables";',
    "$icons: (",
    ...ICONS_METADATA.map(i => `  "${i.className.replace("pt-icon-", "")}": $${i.className},`),
    ");",
);

// simple variable definitions
writeLinesToFile("_icon-variables.scss", ...ICONS_METADATA.map(icon => `$${icon.className}: "${icon.content}";`));

// map ENUM_NAME to className (cast as string constant so it can be used as IconName)
writeLinesToFile("iconClasses.ts", ...buildTSObject("IconClasses", icon => `${icon.className}" as "${icon.className}`));

// union type of all valid string names
writeLinesToFile("iconName.ts", ...buildUnionType());

// map ENUM_NAME to unicode character
writeLinesToFile("iconStrings.ts", ...buildTSObject("IconContents", icon => icon.content.replace("\\", "\\u")));

(async () => {
    // SVG path strings. IIFE to unwrap async.
    writeLinesToFile(
        "iconSvgPaths.ts",
        'import { IconName } from "./iconName";',
        "",
        "export const IconSvgPaths16: Record<IconName, string[]> = {",
        ...(await buildPathsObject("IconSvgPaths", 16)),
        "};",
        "",
        "export const IconSvgPaths20: Record<IconName, string[]> = {",
        ...(await buildPathsObject("IconSvgPaths", 20)),
        "};",
    );
})();

/**
 * Writes lines to given filename in GENERATED_SRC_DIR.
 * @param {string} filename
 * @param {Array<string>} lines
 */
async function writeLinesToFile(filename, ...lines) {
    const outputPath = path.join(GENERATED_SRC_DIR, filename);
    const contents = [COPYRIGHT_HEADER, ...lines, ""].join("\n");
    fs.writeFileSync(outputPath, contents);
}

/**
 * Converts icon className to uppercase constant name.
 * Example: `"pt-icon-time"` &rArr; `"TIME"`
 * @param {IconMetadata} icon
 */
function toEnumName(icon) {
    return icon.className
        .replace("pt-icon-", "")
        .replace(/-/g, "_")
        .toUpperCase();
}

/**
 * Builds `const ${objectName}`, keyed by icon enum name. Value is result of `valueGetter` function.
 * @param {string} objectName
 * @param {(icon: IconMetadata) => string} valueGetter
 */
function buildTSObject(objectName, valueGetter) {
    return [
        `export const ${objectName} = {`,
        ...ICONS_METADATA.map(icon => `    ${toEnumName(icon)}: "${valueGetter(icon)}",`),
        "};",
    ];
}

/**
 * Returns union type of all icon names, including both short (`"time"`) and long (`"pt-icon-time"`) formats.
 */
function buildUnionType() {
    const shortNames = ICONS_METADATA.map(({ className }) => `"${className.replace("pt-icon-", "")}"`);
    const longNames = ICONS_METADATA.map(({ className }) => `"${className}"`);
    // long names extend short names
    longNames.unshift("IconName");
    return [
        `export type IconName =\n    | ${shortNames.join("\n    | ")};`,
        "",
        `export type LegacyIconName =\n    | ${longNames.join("\n    | ")};`,
    ];
}

/**
 * Loads SVG file for each icon, extracts path strings `d="path-string"`,
 * and constructs map of icon name to array of path strings.
 * @param {string} objectName
 * @param {16 | 20} size
 */
async function buildPathsObject(objectName, size) {
    return Promise.all(
        ICONS_METADATA.map(async icon => {
            const filepath = path.resolve(__dirname, `../../resources/icons/${size}px/${icon.className}.svg`);
            const svg = fs.readFileSync(filepath, "utf-8");
            const pathStrings = await svgo
                .optimize(svg, { path: filepath })
                .then(({ data }) => data.match(/ d="[^"]+"/g) || [])
                .then(paths => paths.map(s => s.slice(3)));
            return `    "${icon.className.replace("pt-icon-", "")}": [${pathStrings.join(",\n")}],`;
        }),
    );
}
